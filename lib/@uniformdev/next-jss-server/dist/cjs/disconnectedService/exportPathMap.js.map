{"version":3,"file":"exportPathMap.js","sourceRoot":"","sources":["../../../src/disconnectedService/exportPathMap.ts"],"names":[],"mappings":"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","sourcesContent":["import { ItemDefinition } from '@sitecore-jss/sitecore-jss-manifest';\r\nimport { ManifestManager } from '@sitecore-jss/sitecore-jss-dev-tools';\r\nimport { serverLogger } from '@uniformdev/common-server';\r\nimport { getNextServerConfig } from '@uniformdev/next';\r\n\r\nexport interface PathMap {\r\n    [route: string]: {\r\n        page: string;\r\n    };\r\n}\r\n\r\nexport interface DisconnectedExportPathMapConfig {\r\n    rootPath?: string;\r\n}\r\n\r\nexport const getDisconnectedExportPathMap = ({\r\n    rootPath = process.cwd(),\r\n}: DisconnectedExportPathMapConfig) => async (defaultPathMap: PathMap): Promise<PathMap> => {\r\n    serverLogger.debug('Getting disconnected export path map');\r\n    const { jssAppName, defaultLanguage, appLanguages } = getNextServerConfig();\r\n    let manifestPathMap: PathMap = {};\r\n\r\n    function generateManifestPathMap(route: ItemDefinition, parentPath: string, params?: any, depth = 0) {\r\n        // first/initial route should resolve to `/` instead of a named route.\r\n        // i.e. we don't want `/home`, we just want `/` for the first/initial route.\r\n        const routeName = depth === 0 ? '' : route.name;\r\n        const routePath = `${urlJoin(parentPath, routeName).toLowerCase()}`;\r\n\r\n        manifestPathMap[routePath] = {\r\n            page: '/index',\r\n        };\r\n\r\n        // traverse the route tree\r\n        if (route.children) {\r\n            route.children.forEach((child) => {\r\n                generateManifestPathMap(child as ItemDefinition, routePath, params, (depth += 1));\r\n            });\r\n        }\r\n    }\r\n\r\n    try {\r\n        const manifestManager = new ManifestManager({\r\n            appName: jssAppName,\r\n            rootPath: rootPath,\r\n        });\r\n\r\n        // We ultimately want to merge the `defaultPathMap` with our generated path map so\r\n        // that file-system-based routes, i.e. non-dynamic routes / non-manifest routes, can be\r\n        // exported alongside Sitecore routes. However, we need to remove the default `index` and\r\n        // `/` root path because those paths are reserved for dynamic Sitecore routes.\r\n        const { '/index': index, '/': root, ...nonManifestPathMap } = defaultPathMap;\r\n\r\n        let resolvedPathMap: PathMap = {};\r\n\r\n        // If the app has more than one language, we need to generate a path map for each language so\r\n        // we can prefix routes with a language parameter. We also need to modify the nonManifestPathMap\r\n        // routes to add language parameter.\r\n        if (Array.isArray(appLanguages) && appLanguages.length > 1) {\r\n            for (let language of appLanguages) {\r\n                const manifest = await manifestManager.getManifest(language);\r\n                // Prefix manifest routes with language name\r\n                generateManifestPathMap(manifest.items.routes[0], `/${language}`);\r\n\r\n                // `nonManifestPathMap` entries will not have a language prefix, so we iterate the paths and\r\n                // add a language prefix where possible.\r\n                for (let [key, value] of Object.entries(nonManifestPathMap)) {\r\n                    const pathWithLanguage = `${urlJoin(language, key)}`;\r\n                    const manifestPath = manifestPathMap[pathWithLanguage];\r\n                    // If the generated path map already contains the constructed `{language}/{path}` key, use it\r\n                    // instead of the default/nonManifest path.\r\n                    if (manifestPath) {\r\n                        continue;\r\n                    }\r\n\r\n                    manifestPathMap[pathWithLanguage] = value;\r\n                }\r\n            }\r\n\r\n            resolvedPathMap = manifestPathMap;\r\n        } else {\r\n            const language = defaultLanguage;\r\n            const manifest = await manifestManager.getManifest(language);\r\n            generateManifestPathMap(manifest.items.routes[0], `/`);\r\n\r\n            // Merged the `nonManifestPathMap` with the generated path map.\r\n            // Duplicate path keys will be overwritten by the generated path map.\r\n            resolvedPathMap = {\r\n                ...nonManifestPathMap,\r\n                ...manifestPathMap,\r\n            };\r\n        }\r\n        return resolvedPathMap;\r\n    } catch (error) {\r\n        serverLogger.error(error);\r\n        return {};\r\n    }\r\n};\r\n\r\nfunction urlJoin(...parts: string[]) {\r\n    // Trim each part to remove slashes (leading or trailing), then join the parts using a slash.\r\n    const joinedParts = parts.map((part) => trim(part, '/')).join('/');\r\n    // Trim any extraneous slashes from the joined parts, then prefix the result with a slash\r\n    // to ensure a leading slash.\r\n    return `/${trim(joinedParts, '/')}`;\r\n}\r\n\r\nfunction trim(str: string, char: string) {\r\n    function getSliceStartIndex(str1: string) {\r\n        let startCharIndex = -1;\r\n        while (str1.charAt(++startCharIndex) === char);\r\n        return startCharIndex;\r\n    }\r\n\r\n    function getSliceEndIndex(str1: string) {\r\n        let endCharIndex = str1.length;\r\n        while (str1.charAt(--endCharIndex) === char);\r\n        return endCharIndex + 1;\r\n    }\r\n    return str.slice(getSliceStartIndex(str), getSliceEndIndex(str));\r\n}\r\n"]}