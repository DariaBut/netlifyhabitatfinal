{"version":3,"file":"SitecoreLink.js","sourceRoot":"","sources":["../../../src/components/SitecoreLink.tsx"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,6CAAuC;AACvC,6GAA6G;AAC7G,0EAA0E;AAC1E,2CAA2C;AAC3C,yDAAuE;AACvE,aAAa;AACb,kEAAsE;AAEtE,mDAA6B;AAC7B,qDAAuD;AAEvD,8FAA8F;AAC9F,+FAA+F;AAC/F,4DAA4D;AAC5D,8FAA8F;AAC9F,iGAAiG;AACjG,6FAA6F;AAEhF,QAAA,eAAe,GAAG,UAAC,KAAU;IACtC,IAAM,eAAe,GAAG,oCAAkB,EAAE,CAAC;IAC7C,IAAM,sBAAsB,GACxB,eAAe,IAAI,CAAC,eAAe,CAAC,WAAW,IAAI,eAAe,CAAC,SAAS,KAAK,SAAS,CAAC,CAAC;IAEhG,kEAAkE;IAClE,uFAAuF;IACvF,0DAA0D;IAC1D,IAAM,UAAU,GAAG,eAAO,CAAC,cAAM,OAAA,kBAAkB,EAAlB,CAAkB,EAAE;QACjD,KAAK,CAAC,IAAI;QACV,KAAK,CAAC,MAAM;QACZ,eAAe,CAAC,IAAI,CAAC,IAAI;KAC5B,CAAC,CAAC;IAEH,IAAI,sBAAsB,EAAE;QACxB,wFAAwF;QAExF,wHAAwH;QACxH,UAAU;QACJ,IAAA,KAAe,UAAU,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,EAAE,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,EAAxE,IAAI,UAAA,EAAE,EAAE,QAAgE,CAAC;QACjF,IAAM,cAAY,GAAG,EAAE,IAAI,IAAI,CAAC;QAEhC,OAAO,CACH,8BAAC,eAAK,CAAC,QAAQ,QACV,eAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,QAAQ,EAAE,UAAC,KAAK;YACtC,OAAO,eAAK,CAAC,YAAY,CAAC,KAAK,EAAE,EAAE,IAAI,EAAE,cAAY,EAAE,CAAC,CAAC;QAC7D,CAAC,CAAC,CACW,CACpB,CAAC;KACL;SAAM;QACH,OAAO,8BAAC,cAAI,eAAK,KAAK,EAAI,CAAC;KAC9B;AACL,CAAC,CAAC;AAEF,+CAA+C;AAC/C,SAAS,kBAAkB,CAAC,IAAY,EAAE,MAAc,EAAE,QAAgB;IACtE,IAAM,aAAa,GAAG,aAAW,QAAU,CAAC;IAC5C,IAAM,aAAa,GAAG,UAAU,CAAC,oBAAW,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC;IAC9E,IAAM,WAAW,GAAG,MAAM,CAAC,CAAC,CAAC,UAAU,CAAC,oBAAW,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;IAEhG,OAAO;QACH,IAAI,EAAE,aAAa;QACnB,EAAE,EAAE,WAAW;KAClB,CAAC;AACN,CAAC;AAED,SAAS,UAAU,CAAC,GAAW,EAAE,KAAa;IAC1C,OAAO,KAAG,GAAG,IAAG,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,IAAG,KAAO,CAAC;AAClE,CAAC;AAED,SAAS,SAAS,CAAC,GAAW;IAC1B,OAAO,GAAG,IAAI,OAAO,GAAG,KAAK,QAAQ,CAAC,CAAC,CAAC,4BAAoB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;AAC5E,CAAC","sourcesContent":["import React, { useMemo } from 'react';\r\n// Although the `formatWithValidation` and `addBasePath` functions are declared in the `next-server` package,\r\n// we can still import them for usage in code that will run on the client.\r\n// `next/link` does the same without issue.\r\nimport { formatWithValidation } from 'next/dist/next-server/lib/utils';\r\n// @ts-ignore\r\nimport { addBasePath } from 'next/dist/next-server/lib/router/router';\r\n\r\nimport Link from 'next/link';\r\nimport { useSitecoreContext } from './SitecoreContext';\r\n\r\n// When in experience editor, _attempt_ to render \"standard\" links, e.g. <a href=\"\" /> instead\r\n// of `next/link` components in order to avoid client-side route switches in experience editor.\r\n// Client-side routing will usually break experience editor.\r\n// NOTE: it is _not_ recommended for content editors to use app navigation to navigate between\r\n// pages in experience editor. Especially in a multi-site configuration where the hostname of the\r\n// site being edited may not match the hostname used for logging into the Sitecore CM server.\r\n\r\nexport const SitecoreNavLink = (props: any) => {\r\n    const sitecoreContext = useSitecoreContext();\r\n    const isPageEditingOrPreview =\r\n        sitecoreContext && (sitecoreContext.pageEditing || sitecoreContext.pageState === 'preview');\r\n\r\n    // The function is memoized so that no extra lifecycles are needed\r\n    // as per https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html\r\n    // This idea/code borrowed from the `next/link` component.\r\n    const formatUrls = useMemo(() => memoizedFormatUrls, [\r\n        props.href,\r\n        props.asHref,\r\n        sitecoreContext.site.name,\r\n    ]);\r\n\r\n    if (isPageEditingOrPreview) {\r\n        // need to resolve the intended `href` of the link here, and append the `sc_site` param.\r\n\r\n        // presumably, if an `as` prop is provided, that is the \"actual\" URL that would be sent in a server request to Sitecore?\r\n        // or not?\r\n        const { href, as } = formatUrls(props.href, props.as, sitecoreContext.site.name);\r\n        const resolvedHref = as || href;\r\n\r\n        return (\r\n            <React.Fragment>\r\n                {React.Children.map(props.children, (child) => {\r\n                    return React.cloneElement(child, { href: resolvedHref });\r\n                })}\r\n            </React.Fragment>\r\n        );\r\n    } else {\r\n        return <Link {...props} />;\r\n    }\r\n};\r\n\r\n// This code largely borrowed from `next/link`.\r\nfunction memoizedFormatUrls(href: string, asHref: string, siteName: string) {\r\n    const siteNameParam = `sc_site=${siteName}`;\r\n    const formattedHref = addQsParam(addBasePath(formatUrl(href)), siteNameParam);\r\n    const formattedAs = asHref ? addQsParam(addBasePath(formatUrl(asHref)), siteNameParam) : asHref;\r\n\r\n    return {\r\n        href: formattedHref,\r\n        as: formattedAs,\r\n    };\r\n}\r\n\r\nfunction addQsParam(url: string, param: string) {\r\n    return `${url}${url.indexOf('?') !== -1 ? '&' : '?'}${param}`;\r\n}\r\n\r\nfunction formatUrl(url: string) {\r\n    return url && typeof url === 'object' ? formatWithValidation(url) : url;\r\n}\r\n\r\n"]}